## [추상 클래스와 인터페이스의 차이점]

* 추상 클래스에서 추상 메소드가 아닌 일반 인스턴스 메소드의 경우, **final을 붙이면 오버라이딩이 불가능해진다.** 즉, 제공하는 기능을 그대로 사용해야하는 것.

* 위와 같이 final을 응용하면, 다른 추상 메소드들에 대해서도 호출 순서를 다음과 같이 강제할 수 있다.
```java
	final void start(){
		test_01();
		test_02();
		test_03();
		// test 함수들을 오버라이딩 하더라도 순서를 수정할 수는 없다
	}
```

* 추상 클래스와 다르게 인터페이스는 다중 상속이 가능
* 추상 클래스는 (기능 + 규격), 인터페이스는 (규격) 으로 이해하는 것이 좋다.

## [상속, 추상클래스, 인터페이스의 관계에 대해서]

* **상속 (extends)** : 기존의 것을 확장하는 개념
* **인터페이스 (implements)** : 설계(계획)을 실제로 구현하는 개념
* **추상 클래스 (abstract)** : 상속과 인터페이스의 중간 개념 (상속:기존의 것을 확장하는데, 인터페이스:일정한 계획에 따라 확장을 구현)

* 인터페이스(계획, 설계) -> 추상 클래스(미완성된 구현, 확장 가능성 보유) -> 일반 클래스(최종 구현)

## [예외처리 (Exception)]

* 예외처리 클래스에는 세가지가 있다.
	* 체크 예외 : 컴파일 중 문법 에러를 체크하는 예외 (throws 필수)
	* 언체크 예외 : 런타임 중 발생하는 에러 (throws 생략 가능)
	* 사용자 정의 예외 -체크예외 클래스(Exception)을 상속받았을 경우 : throws를 명시해야함
	* 사용자 정의 예외 - 언체크예외 클래스 (RuntimeException)을 상속받았을 경우 : throws 생략 가능

### 1. 기본적인 예외처리 문법
```java
	try {
		// 클래스를 로딩 하며 존재하는지 확인하는 함수
		Class.forName("java.lang.String");
		System.out.println("java.lang.String 클래스가 존재합니다.");
	} catch (ClassNotFoundException e) {
		// 예외가 발생했을 경우
		//System.out.println(e.getMessage());  //예외 정보를 얻는 방법1
		//System.out.println(e.toString());  // 예외 정보를 얻는 방법2
		e.printStackTrace();   // 예외 정보를 얻는 방법3
	} finally {
		// 예외가 발생하든, 발생하지 않았든 반드시 실행
		System.out.println("마무리 실행\n");
	}
```

### 2. 예외처리 클래스간 상속개념, 2가지 예외에 대해 동일하게 처리하는 문법
```java
            try {
                assert stringarray[i] != null;
                int value = Integer.parseInt(stringarray[i]);
		  //} catch(Exception e){
		  //	여러개의 Exception 클래스를 catch하고자 할 때,
		  //	부모클래스보다 자식클래스의 예외를 먼저 catch 해줘야한다.
	   	  //    e.getMessage();
            } catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("배열 인덱스가 초과되었습니다." + e.getMessage());
            } catch (NullPointerException | NumberFormatException e1){
				//2가지 예외를 동일하게 처리 방식
                System.out.println("실행에 문제가 있습니다.." + e1.getMessage());  
            }
```

### 3. 예외를 전달하는 방법 (throw를 사용하는 문법)
```java
    // 문자열을 숫자로 바꾸는 프로그램
    public static void main(String[] args) {
        Scanner scan= new Scanner(System.in);
        System.out.println("숫자로 변환할 문자열을 입력바랍니다.");
        String str= scan.nextLine();
        int result= 0;

        try {
            result = convert(str);
            System.out.println("변환된 숫자는 " + result + " 입니다.");
        } catch (IllegalArgumentException e) {
            // 매개변수로 전달된 값에 이상이 있는 경우
            System.out.println(e.getMessage());
        }

    }

    // IllegalArgumentException 예외는 런타임 예외이므로 throws 필요 없음
    // 컴파일시 체크하는 예외 : 체크 예외 / 런타임시 발생하는 예외 : 언체크 예외
    private static int convert(String str) {
        //여기를 작성하십시오.
        if (str == null || str.length() == 0) {
            // str 객체가 비어있을 수도 있으므로, 길이 검사하는 함수를 호출하기 전에 null에 대한 검사를 우선한다.
            throw new IllegalArgumentException("예외가 발생되었습니다. 문자열을 입력하지 않고 Enter키를 누르셨습니다.");
        } else if (!str.matches("-?\\d+(\\.\\d+)?")) {
            // -? : 음수 부호가 올 수도, 안 올 수도 있음 -> 어떤 경우에도 허용
            // \\d : 0~9 한자리 수
            // \\d+ : 0~9로 이뤄진 여러자리 수
            // \\. : . 하나
            // (\\.\\d+)? : (. 하나와 그 뒤로 여러개의 숫자)가 올 수도, 안 올 수도 있음
            // !str.matches("-?\\d+(\\.\\d+)?") : 즉, (음수 정수, 음수 소수, 양수, 양수 소수) 가 아닌 경우에 대해 아래 예외처리 발생
            throw new NumberFormatException("예외가 발생되었습니다. 숫자만 입력해주세요.");
        }

        // 실수가 입력되는 경우를 대비
        return (int) Double.parseDouble(str);
    }
```

### 4. try-with-resources 문법을 활용한 파일입출력 예제

* 파일 쓰기
```java
	try (FileWriter file = new FileWriter("data2.txt")) {
		// file은 try-with-resources문에서 생성되었으므로,
		// try 블록을 빠져나오면 자동으로 close()를 호출
		file.write("Java Programming");
	} catch (IOException e) {
		e.printStackTrace();
	}

```

* 파일 읽기
```java
	try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
		String data;
		while ((data = br.readLine()) != null) {
			// 파일이 끝날 때까지 줄 단위로 읽어서 출력
			System.out.println(data);
		}
	} catch (IOException e) {
		e.printStackTrace();
	}
```

* AutoCloseable 인터페이스 : java7 이상에서 이미 구현해서 제공하는 인터페이스, AutoCloseable를 구현한 사용자 정의 클래스는 try-with-resources에서 자동으로 close()가 호출되도록 할 수 있다.
* Closeable 인터페이스 : java5 이상에서 이미 구현해서 제공하는 인터페이스, 마찬가지로 close()를 자동 호출되게 할 수있지만, IOException만 던질 수 있다.

### 5. 사용자 정의 예외클래스
```java
	//일반 예외로 선언한 사용자정의 예외클래스
	public class InsufficientEx extends Exception{   
		public InsufficientEx(){}

		public InsufficientEx(String message) {
			// 예외처리에 대한 정보를 message를 통해 super로 전달
			super(message);
		}
	}
	
	public class Account {

		// (중략)
		
		//호출한 곳으로 예외 떠넘김
		public void withdraw(int money) throws InsufficientEx{ 
			if(this.balance < money) {
				throw new InsufficientEx("잔고 부족으로 출금이 안됩니다." + (money-this.balance)+"부족합니다.");
			}
			this.balance -= money;
		}
	}
	
	public class Main {
		public static void main(String[] args) {
			Account account = new Account();

			account.deposit(100000);
			System.out.println("현재 잔고는 " + account.getBalance());

			// 사용자 정의 예외를 throw 받는 곳
			try {
				account.withdraw(300000);
			} catch (InsufficientEx e) {
				String message = e.getMessage();
				System.out.println(message);
			}
		}
	}
```

## [인터페이스 -> 추상클래스 -> 일반클래스의 연계 과정 및 예외처리 예제]

### 1. 사용자 정의 예외 클래스 PayException
```java
	public class PayException extends Exception {
		// Exception을 상속받았으므로 throws를 명시해야하는 체크 예외 클래스가 됨
		// 만약 RuntimeException을 상속받을 경우 throws를 생략해도 되는 언체크 예외 클래스가 된다.
		public PayException(String message){
			super(message);
		}
	}
```

### 2. PayException를 throw하는 pay함수를 설계하는 인터페이스 Payable
```java
	public interface Payable {
		// 1.
		// 인터페이스 Payable을 상속받은 클래스는 반드시 pay 함수를 정의해야한다.
		// 이때, pay 함수는 PayException에 대한 예외를 던지거나(throw), 직접 처리(try-catch)해야 한다.

		// 2.
		// 인터페이스에서 선언되었으므로 pay 함수는 abstract 키워드 없이도 자동으로 추상 메소드가 된다.
		public void pay() throws PayException ;
	}
```

### 3. Payable 인터페이스를 대략적으로 구현하는 추상클래스 Payment
```java
	// 상속(extends) : 기존의 것을 확장하는 개념
	// 인터페이스(implements) : 설계(계획)을 실제로 구현하는 개념
	//      -> Payable 계획에 따라 Payment 클래스를 구현하시오.
	//      -> Payment 클래스는 Payable 계획에 따라 구현되었다.
	// 추상 클래스(abstract) : 상속과 인터페이스의 중간 개념
	//      -> 기존의 것을 확장하는데 일정한 계획에 따라 확장을 구현
	public abstract class Payment implements Payable {
		protected String shopName;
		protected String productName;
		protected long productPrice;

		// 생성자
		public Payment(String shopName, String productName, long productPrice) {
			this.shopName = shopName;
			this.productName = productName;
			this.productPrice = productPrice;
		}

		// 추상 클래스는 인터페이스의 추상 메소드(pay())를 구현할 의무가 없다.
		// 대신 추상 클래스를 상속받는 일반 클래스가 구현의 의무를 진다.
		// 인터페이스(계획, 설계) -> 추상 클래스(미완성된 구현, 확장 가능성 보유) -> 일반 클래스(최종 구현)
	}
```

### 4. Payment를 카드결제 컨셉으로 완벽하게 구현해내는 일반클래스(1) CardPayment
```java
	public class CardPayment extends Payment {
		private String cardNumber;
		private String cardPassword;
		private int monthlyInstallment;

		// 생성자
		CardPayment(String shopName, String productName, long productPrice,
					String cardNumber, String cardPassword, int monthlyInstallment) {
			super(shopName, productName, productPrice);
			this.cardNumber = cardNumber;
			this.cardPassword = cardPassword;
			this.monthlyInstallment = monthlyInstallment;
		}

		// (인터페이스->추상클래스)로 전달받은 추상 메소드 오버라이딩
		@Override
		public void pay() throws PayException {
			if (this.productPrice <= 0 || this.monthlyInstallment < 0) {
				throw new PayException("가격이나 할부개월수가 잘못되었습니다.");
			}
		}

		// 객체명을 이용해 문자열 출력을 하기 위한 함수
		@Override
		public String toString() {
			return "신용카드가 정상적으로 지불되었습니다.\n" +
					"[ 신용카드 결제 정보 ]\n" +
					"상점명 : " + this.shopName + "\n" +
					"상품명 : " + this.productName + "\n" +
					"상품가격 : " + this.productPrice + "\n" +
					"신용카드번호 : " + this.cardNumber + "\n" +
					"할부개월 : " + this.monthlyInstallment;
		}
	}
```

### 5. Payment를 현금결제 컨셉으로 완벽하게 구현해내는 일반클래스(2) CashPayment
```java
	public class CashPayment extends Payment {
		private String cashRecelptNumber;

		// 생성자
		CashPayment(String shopName, String productName, long productPrice,
					String cashRecelptNumber) {
			super(shopName, productName, productPrice);
			this.cashRecelptNumber = cashRecelptNumber;
		}

		// (인터페이스->추상클래스)로 전달받은 추상 메소드 오버라이딩
		@Override
		public void pay() throws PayException {
			if (this.productPrice <= 0) {
				throw new PayException("가격이 잘못되었습니다.");
			}
		}

		// 객체명을 이용해 문자열 출력을 하기 위한 함수
		@Override
		public String toString() {
			return "현금이 정상적으로 지불되었습니다.\n" +
					"[ 현금 결제 정보 ]\n" +
					"상점명 : " + this.shopName + "\n" +
					"상품명 : " + this.productName + "\n" +
					"상품가격 : " + this.productPrice + "\n" +
					"현금영수증번호 : " + this.cashRecelptNumber;
		}
	}
```

### 6. CardPayment, CashPayment 클래스를 테스트하는 main함수
```java
	public class PayMentTest {
		public static void main(String[] args) throws PayException {
			CardPayment card1 = new CardPayment("11번가","Java책",17000,"123-432-111","0070",0);
			payProcess( card1 );
			System.out.println("-------------------------------------");
			CashPayment cash1 = new CashPayment("인터파크","에어컨",2400000,"198-32");
			payProcess( cash1 );
			System.out.println("-------------------------------------");
			
			CardPayment card2 = new CardPayment("예스24","소설책",2000,"843-12-434","1234",-2);
			try {
				payProcess( card2 );
			} catch (PayException e) {
				System.out.println("예외 : " + e.getMessage());
			}

			CashPayment cash2 = new CashPayment("G마켓","핸드폰",0,"999-56");
			try {
				payProcess( cash2 );
			} catch (PayException e) {
				System.out.println("예외 : " + e.getMessage());
			}

		}

		public static void payProcess( Payment p ) throws PayException {
			p.pay();
			System.out.println( p );
		}
	}
```